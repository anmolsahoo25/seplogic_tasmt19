\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}

\usetheme{Madrid}
\usecolortheme{default}
\newcommand\sepimp{\mathrel{-\mkern-6mu*}}

\newcommand{\mscmt}[1]{{\color{blue} [Srivas: {#1}]}}
\newcommand{\sncmt}[1]{{\color{green} [Srinidhi: {#1}]}}


%------------------------------------------------------------
%This block of code defines the information to appear in the
%Title page
\title %optional
{Introduction to Separation Logic}

\author[\footnote{Heavily}]% (optional)
{Heavily borrows from slides by Cristiano Calcagno, Imperial College London}


%End of title page configuration block
%------------------------------------------------------------



%------------------------------------------------------------
%The next block of commands puts the table of contents at the 
%beginning of each section and highlights the current section:

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}
%------------------------------------------------------------


\begin{document}

%The next statement creates the title page.
\frame{\titlepage}



%---------------------------------------------------------
%This block of code is for the table of contents after
%the title page
\begin{frame}
\frametitle{Table of Contents}
\tableofcontents
\end{frame}
%---------------------------------------------------------


\section{Introducing Separation Logic}

%---------------------------------------------------------
\begin{frame}
\frametitle{Syntax of Separation Logic}
\begin{itemize}
\item Given a decidable base-theory $T$, the syntax of separation logic $SL(T)_{Loc,Data}$ is presented
\item $Loc$ and $Data$ represent the type of the address and the values
\item $Loc$ and $Data$ can be any sorts, but $Loc$ should be countably
    infinite, for the purpose of the decision procedure
\item For example, $Loc$ and $Data$ can be $Int$
\end{itemize}

\begin{align*}
    P,Q ::= \; false \;
          & \lvert \; P \land Q \;
          \lvert \; P \lor Q \;
          \lvert \; P \to Q \\
          & \lvert \; P * Q \;
            \lvert \; P \sepimp Q \\
          & \lvert E = E' \;
            \lvert E \hookrightarrow E' \;
            \lvert empty
\end{align*}

We use $E$ and $E'$ to denote expressions in the base theory,
where heap indirection is not used. This is needed to syntactically
rule out formulas like $F : (x \hookrightarrow v_1) = (y \hookrightarrow v_2)$
\end{frame}
%---------------------------------------------------------


\begin{frame}
\frametitle{Semantics of Separation Logic}
The model consists of an interpretation $(I)$ and a heap $(h)$

\begin{align*}
    I &: \textrm{Var} \to \textrm{Loc} \\ 
    h &: \textrm{Loc} \to \textrm{Data}
\end{align*}

\begin{align*}
    I,h &\models false \hspace{3.5cm}     & \textrm {never satisfied} \\
    I,h &\models P \land Q \hspace{3.5cm} & I,h \models P \; \textrm{and} \; I,h \models Q \\
    I,h &\models P \lor Q \hspace{3.5cm} & I,h \models P \; \textrm{or} \; I,h \models Q \\
    I,h &\models P \to Q \hspace{3.5cm} & I,h \models P \; \textrm{implies} \; I,h \models Q \\
    I,h &\models E = E' \hspace{3.5cm} & [\![ E ]\!]_I = [\![ E' ]\!]_I
\end{align*}

We use $[\![E]\!]_I$, to denote the value of $E$ under the interpretation $I$. Also, the domain of $h$ should be a subset of $Loc$ and it can be
a partial function.
\end{frame}

\begin{frame}
\frametitle{Semantics of Separation Logic}

Empty heap
\begin{align*}
    I,h \models empty \\ 
    \textrm{iff} \; h = \phi
\end{align*}

Separating conjunction
\begin{align*}
    I,h \models P * Q \hspace{3.5cm} \\ 
    \textrm{iff} \; \exists h_1,h_2.(h_1 \# h_2) \land (h = h1 \circ h2) \land I,h_1 \models P \land I,h_2 \models Q \\
\end{align*}

Where $h_1 \# h_2$ denotes that the heap domains are disjoint and $h_1 \circ h_2$ means their union. \\
\end{frame}

\begin{frame}
\frametitle{Semantics of Separation Logic}

Separating Implication
\begin{align*}
    I,h \models P \sepimp Q \hspace{3.5cm} \\ 
    \textrm{iff} \; \forall h'.(h \# h') \land (I,h' \models P) \to I,h \circ h' \models Q
\end{align*}

Interpretation : If we extend the current heap with a disjoint heap satisfying P, then the new heap satisfies Q. In some ways, we can imagine that our current heap is only missing the records of P, to make it satisfy Q.
\vspace{0.5cm} \\

Points to
\begin{align*}
    I,h \models E \hookrightarrow E' \\ 
    \textrm{iff} \; h([\![ E ]\!]_I) = [\![ E' ]\!]_I
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Examples}
Points to, 
\begin{align*}
    & F : x \hookrightarrow 10 \\
    & I : \{(x,0)\} \\
    & h : \{(0,10)\} \\
    & I,h \models F
\end{align*}

Separating conjunction,
\begin{align*}
    & F : x \hookrightarrow 10 * y \hookrightarrow 20 \\
    & I : \{ (x,0), (y,1) \} \\
    & h : \{(0,10), (1,20)\} \\
    & I,h \models F
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Examples}
Another example,
\begin{align*}
    & F : x \hookrightarrow y * y \hookrightarrow x \\
    & I : \{(x,0), (y,1)\} \\
    & h : \{(0,1), (1, 0)\} \\
    & I,h \models F
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Examples}
Separating Implication
\begin{align*}
    I,h \models P \sepimp Q \hspace{3.5cm} \\ 
    \textrm{iff} \; \forall h'.(h \# h') \land (I,h' \models P) \to I,h \circ h' \models Q
\end{align*}

Example,
\begin{align*}
    & F : (x \hookrightarrow 10) \sepimp (x \hookrightarrow 10 * y \hookrightarrow 20) \\
    & I : \{(x,0), (y,1)\} \\
    & h' : \{(0,10)\} \\
    & h : \{(1,20) \} \\
    & h \circ h' : \{(0,10), (1,20)\} \\
    & I,h \models F
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Applications}
Separation logic has been useful in Hoare logic for program verification. We will
have a quick look at Hoare logic.

\begin{align*}
    & \{P\}S\{Q\} \\
    & P : \textrm{Logical assertion on states - precondition} \\
    & S : \textrm{Code section that modifies state} \\
    & Q : \textrm{Logical assertion on states - postcondition}
\end{align*}

Example,
\begin{align*}
    \{x = 1\}x := 2\{x = 2\}
\end{align*}

The programs $S$ are defined against a language specification with 
imperative commands such as skip, loops,
variable and pointer assignments.
\end{frame}

\begin{frame}
\frametitle{Applications}
Now given a post-condition $Q$ and program $S$, we want to calculate the set
of states, that the program can be in before, to end-up in $Q$ after execution.

Example,
\begin{align*}
    \{x > 0\}x := x + 1\{x >= 0\}
\end{align*}

This is also valid,
\begin{align*}
    \{x > -1\}x := x + 1\{x >= 0\}
\end{align*}

In fact, $(x > -1) \to (x > 0)$, thus, $(x > -1)$ is weaker. Finding the
weakest unique precondition, can then let us reason about all the states,
that the program can be in before, to guarantee $Q$ to hold.
\end{frame}

\begin{frame}
\frametitle{Applications}
The first application of separation logic in Hoare-style verification is
to do local reasoning, which is defined as,

\begin{align*}
    \frac{\{P\} S \{Q\}}{\{P * R\} S \{Q * R\}}
\end{align*}

Example,
\begin{align*}
    & \{\textrm{root} \hookrightarrow (\textrm{left}, \textrm{right}) * \textcolor{red}{\textrm{tree(left)}} * \textrm{tree(right)}\} \\
    & \textrm{deletetree(left)} \\
    & \{\textrm{root} \hookrightarrow (\textrm{left}, \textrm{right}) * \textcolor{green}{\textrm{emp}} * \textcolor{red}{\textrm{tree(right)}}\} \\
    & \textrm{deletetree(right)} \\
    & \{\textrm{root} \hookrightarrow (\textrm{left}, \textrm{right}) * \textrm{emp} * \textcolor{green}{\textrm{emp}}\} \\
    & \textrm{free(root)} \\
    & \{\textrm{emp} * \textrm{emp} * \textrm{emp}\} \\
    & \{\textrm{emp}\}
\end{align*}
\end{frame}

\begin{frame}
\frametitle{Applications}
Another application is to have a modus-ponens similar operation for heaps.

\begin{align*}
    P * (P \sepimp Q) \models Q
\end{align*}
Example,
\begin{align*}
    (x \hookrightarrow v_1) * (x \hookrightarrow v_1 \sepimp y \hookrightarrow v_2) \models (y \hookrightarrow v_2)
\end{align*}
Also, this is used in weakest pre-condition computation, where if we have a triple,
    \begin{align*}
    \{P\}x := 3\{Q\}
    \end{align*}
where the weakest precondition would be,
    \begin{align*}
        wp(x := 3, Q) \equiv (x \hookrightarrow -) * ((x \hookrightarrow 3) \sepimp Q)
    \end{align*}
\end{frame}
\section{Relation with Pointer Logic}

\begin{frame}
\frametitle{Translating Separation Logic into Pointer Logic}
Points to,
\begin{align*}
    I,h & \models x \hookrightarrow v \\
    & \Longleftrightarrow \\
    L,M & \models \ ^*x = v
\end{align*}

Separating conjunction,
\begin{align*}
    I,h & \models x \hookrightarrow v_1 * y \hookrightarrow v_2 \\
    & \Longleftrightarrow \\
    L,M & \models \ ^*x = v_1 \; \land \ ^*y = v_2 \land x \neq y
\end{align*}
\end{frame}

\section{Inductive predicates}
\begin{frame}
\frametitle{Need for inductive predicates}
\begin{itemize}
    \item Most interesting data structures in programs are defined as inductive systems
    \item For example : linked lists, trees, graphs
    \item Being able to reason about these in SL is useful
    \item But inductive predicates introduce quantifiers
\end{itemize}
	\vspace{0.5cm}
This way of specifying a list is quite cumbersome,
    \begin{align*}
        & p \hookrightarrow v_1,p_1 \; \land \\
        & p_1 \hookrightarrow v_2, p_2 \; \land \\
        & p_2 \hookrightarrow v_3, p_3 \; \land \\
        & \ldots
    \end{align*}
\end{frame}

\begin{frame}
\frametitle{Lists in pointer logic}
	First try at defining lists without explicit quantifiers. We define the following predicates for the $i^{th}$
element of the list,
\begin{align*}
	& \textrm{list-elem}(p,0) \equiv p \\
	& \textrm{list-elem}(p,i) \equiv *\textrm{list-elem}(p,i-1)
\end{align*}
In this formulation, a null-terminated list would be \\
\begin{align*} \textrm{list-elem}(p,l) = NULL
\end{align*}
and a cyclic list would be,
\begin{align*} \textrm{list-elem}(p,l) = p \end{align*}
But the last predicate is also satisfied by an element with length 1.
\end{frame}

\begin{frame}
\frametitle{Lists in pointer logic}
To actually get a disjoint list with unique pointer elements,
we need to add an extra constraint,
\begin{align*}
	& \textrm{overlap}(p,q) \equiv p = q \lor p + 1 = q \lor p = q + 1 \\
	& \textrm{list-disjoint}(p,0) \equiv TRUE \\
	& \textrm{list-disjoint}(p,l) \equiv
	\textrm{list-disjoint}(p,l-1) \land \\
	& \forall 0 \leq i < l - 1.
	\neg \; \textrm{overlap}(
	\textrm{list-elem}(p,i), \textrm{list-elem}(p,l-1))
\end{align*}
The set of clauses grows quadratically upon the quantifier instantiation.
\end{frame}

\begin{frame}
\frametitle{Lists - Try 2}
We use inductive predicates to define lists,
\begin{align*}
    & \textrm{list} \; 0 \; x \equiv empty \land x = nil
    \\
    & \textrm{list} \; n \; x \equiv \exists y. (x \hookrightarrow n,y) * (list \; (n-1) \; y)
\end{align*}

\begin{itemize}
    \item This defines a linked-list rooted at $x$
    \item Base case : empty list where heap is empty and root pointer is null
    \item Inductive case : the root points to a struct which has a value and the pointer for the remaining list
    \item Separately, the next pointer points to a list. Prevents pointer aliasing, each pointer is different
\end{itemize}
\end{frame}


\end{document}
